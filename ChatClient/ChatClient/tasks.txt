Friends Request and offline requests

//Friend Request - to be also for offline users

//Sending files
//3. Cancel copy
//4. Progress
//5. Notification


Add notification when Send File, Add Friend based on response
Multiple Send Files to be parallel ???? requires multiple ports






Client:
Getting ip and port from serialization + saving in form
Getting data for addFriend
Solving Conversation Form

Me:
When LogOff stoping servers ... from ChatListener

checking to get offline on servers
Get status from xml


Solving with offline message
Solving with unaccepted friends



change ports to be random for ChatListener




Server:
when command 2 make offline all users

delete friend request
delete sending 0 from client to server when sending message from client to server when adding friend




Need to be done.
Delete unused logos.



Friend Request blocheaza tot formul



3 Importante:
1. Improving file sending
2. History
3. Offline Messages


---------------------------------------
Future:
//TODO Online/NA/Invisible ..
//Logo send



---------------------------------------
Done:

Simulare Add Friend
Simulare Send File

Radu:
Daca nu sa logat sa nu poata optiunea >= 3
daca nu poate face notify la friend request sa-l transforme in cerere offline
Get status from server.

---------------------------------------
Client Interface:
list has scroll disable scroll

GetIpandPort ??

Client App is not closing .



---------------------------------------
Shortcuts:

Ctrl+M+O -> Collapse
Ctrl+M+L -> Expand




--------------------------------------
Trash:


//        private void Send(ServerOperation operation, string obj)
//        {
//            _connStream.WriteByte((byte)operation);
//            Send(obj);
//        }
//
//        private void Send(ServerOperation operation, int number)
//        {
//            _connStream.WriteByte((byte)operation);
//            Send(number);
//        }
//
//        private void Send(string obj)
//        {
//            byte[] ba = Encoding.UTF8.GetBytes(obj);
//
//            _connStream.WriteByte((byte)ba.Length);
//            _connStream.Write(ba, 0, ba.Length);
//        }
//
//        private void Send(int number)
//        {
//            byte[] ba = BitConverter.GetBytes(number);
//
//            if (BitConverter.IsLittleEndian)
//                Array.Reverse(ba);
//
//            _connStream.Write(ba, 0, 4);
//        }